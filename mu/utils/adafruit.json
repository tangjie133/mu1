[
{"name": "microcontroller.Processor", "args": [], "description": ""},
{"name": "microcontroller.Pin", "args": [], "description": "Identifies an IO pin on the microcontroller. They are fixed by the\nhardware so they cannot be constructed on demand. Instead, use\nboard or microcontroller.pin to reference the desired pin.\n\n"},
{"name": "multiterminal.get_secondary_terminal", "args": [], "description": "Returns the current secondary terminal.\n"},
{"name": "multiterminal.set_secondary_terminal", "args": ["stream"], "description": "Read additional input from the given stream and write out back to it.\nThis doesn\u2019t replace the core stream (usually UART or native USB) but is\nmixed in instead.\n\n\n\n\nParameters:stream (stream) \u2013 secondary stream\n\n\n\n"},
{"name": "multiterminal.clear_secondary_terminal", "args": [], "description": "Clears the secondary terminal.\n"},
{"name": "multiterminal.schedule_secondary_terminal_read", "args": ["socket"], "description": "In cases where the underlying OS is doing task scheduling, this notifies\nthe OS when more data is available on the socket to read. This is useful\nas a callback for lwip sockets.\n"},
{"name": "pulseio.PulseIn", "args": ["pin", "maxlen=2", "*", "idle_state=False"], "description": "Create a PulseIn object associated with the given pin. The object acts as\na read-only sequence of pulse lengths with a given max length. When it is\nactive, new pulse lengths are added to the end of the list. When there is\nno more room (len() == maxlen) the oldest pulse length is removed to\nmake room.\n\n\nParameters:\npin (Pin) \u2013 Pin to read pulses from.\nmaxlen (int) \u2013 Maximum number of pulse durations to store at once\nidle_state (bool) \u2013 Idle state of the pin. At start and after resume\nthe first recorded pulse will the opposite state from idle."},
{"name": "pulseio.PulseIn.deinit", "args": [], "description": "Deinitialises the PulseIn and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PulseIn.maxlen", "args": null, "description": "Returns the maximum length of the PulseIn. When len() is equal to maxlen,\nit is unclear which pulses are active and which are idle.\n"},
{"name": "os.uname", "args": [], "description": "Returns a named tuple of operating specific and CircuitPython port\nspecific information.\n"},
{"name": "os.chdir", "args": ["path"], "description": "Change current directory.\n"},
{"name": "os.getcwd", "args": [], "description": "Get the current directory.\n"},
{"name": "os.listdir", "args": ["dir"], "description": "With no argument, list the current directory.  Otherwise list the given directory.\n"},
{"name": "os.mkdir", "args": ["path"], "description": "Create a new directory.\n"},
{"name": "os.remove", "args": ["path"], "description": "Remove a file.\n"},
{"name": "os.rmdir", "args": ["path"], "description": "Remove a directory.\n"},
{"name": "nvm.ByteArray", "args": [], "description": "Not currently dynamically supported. Access the sole instance through microcontroller.nvm.\n\n"},
{"name": "os.rename", "args": ["old_path", "new_path"], "description": "Rename a file.\n"},
{"name": "os.stat", "args": ["path"], "description": "Get the status of a file or directory.\n"},
{"name": "os.statvfs", "args": ["path"], "description": "Get the status of a fileystem.\nReturns a tuple with the filesystem information in the following order:\n\n\nf_bsize \u2013 file system block size\nf_frsize \u2013 fragment size\nf_blocks \u2013 size of fs in f_frsize units\nf_bfree \u2013 number of free blocks\nf_bavail \u2013 number of free blocks for unpriviliged users\nf_files \u2013 number of inodes\nf_ffree \u2013 number of free inodes\nf_favail \u2013 number of free inodes for unpriviliged users\nf_flag \u2013 mount flags\nf_namemax \u2013 maximum filename length\n\n\nParameters related to inodes: f_files, f_ffree, f_avail\nand the f_flags parameter may return 0 as they can be unavailable\nin a port-specific implementation.\n"},
{"name": "os.sync", "args": [], "description": "Sync all filesystems.\n"},
{"name": "os.urandom", "args": ["size"], "description": "Returns a string of size random bytes based on a hardware True Random\nNumber Generator. When not available, it will raise a NotImplementedError.\n"},
{"name": "digitalio.Pull", "args": [], "description": "Enum-like class to define the pull value, if any, used while reading\ndigital values in.\n\n"},
{"name": "digitalio.Pull.UP", "args": null, "description": "When the input line isn\u2019t being driven the pull up can pull the state\nof the line high so it reads as true.\n"},
{"name": "digitalio.Pull.DOWN", "args": null, "description": "When the input line isn\u2019t being driven the pull down can pull the\nstate of the line low so it reads as false.\n"},
{"name": "digitalio.DriveMode", "args": [], "description": "Enum-like class to define the drive mode used when outputting\ndigital values.\n\n"},
{"name": "digitalio.DriveMode.PUSH_PULL", "args": null, "description": "Output both high and low digital values\n"},
{"name": "digitalio.DriveMode.OPEN_DRAIN", "args": null, "description": "Output low digital values but go into high z for digital high. This is\nuseful for i2c and other protocols that share a digital line.\n"},
{"name": "digitalio.DigitalInOut", "args": ["pin"], "description": "Create a new DigitalInOut object associated with the pin. Defaults to input\nwith no pull. Use switch_to_input() and\nswitch_to_output() to change the direction.\n\n\nParameters:pin (Pin) \u2013 The pin to control"},
{"name": "digitalio.DigitalInOut.Direction", "args": [], "description": "Enum-like class to define which direction the digital values are\ngoing.\n\n"},
{"name": "digitalio.DigitalInOut.Direction.INPUT", "args": null, "description": "Read digital data in\n"},
{"name": "digitalio.DigitalInOut.Direction.OUTPUT", "args": null, "description": "Write digital data out\n"},
{"name": "digitalio.DigitalInOut.deinit", "args": [], "description": "Turn off the DigitalInOut and release the pin for other use.\n"},
{"name": "digitalio.DigitalInOut.direction", "args": null, "description": "The direction of the pin.\nSetting this will use the defaults from the corresponding\nswitch_to_input() or switch_to_output() method. If\nyou want to set pull, value or drive mode prior to switching, then use\nthose methods instead.\n"},
{"name": "digitalio.DigitalInOut.value", "args": null, "description": "The digital logic level of the pin.\n"},
{"name": "digitalio.DigitalInOut.drive_mode", "args": null, "description": "Get or set the pin drive mode.\n"},
{"name": "digitalio.DigitalInOut.pull", "args": null, "description": "Get or set the pin pull. Values may be digitalio.Pull.UP,\ndigitalio.Pull.DOWN or None.\n\n\n\n\nRaises:AttributeError \u2013 if the direction is ~`digitalio.Direction.OUTPUT`.\n\n\n\n"},
{"name": "usb_hid.Device", "args": [], "description": "Not currently dynamically supported.\n\n"},
{"name": "usb_hid.Device.send_report", "args": ["buf"], "description": "Send a HID report.\n"},
{"name": "usb_hid.Device.usage_page", "args": null, "description": "The usage page of the device. Can be thought of a category.\n\n\n\n\nReturns:the device\u2019s usage page\n\nReturn type:int\n\n\n\n"},
{"name": "usb_hid.Device.usage", "args": null, "description": "The functionality of the device. For example Keyboard is 0x06 within the\ngeneric desktop usage page 0x01. Mouse is 0x02 within the same usage\npage.\n\n\n\n\nReturns:the usage within the usage page\n\nReturn type:int\n\n\n\n"},
{"name": "touchio.TouchIn", "args": ["pin"], "description": "Use the TouchIn on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "touchio.TouchIn.deinit", "args": [], "description": "Deinitialises the TouchIn and releases any hardware resources for reuse.\n"},
{"name": "touchio.TouchIn.value", "args": null, "description": "Whether the touch pad is being touched or not.\n\n\n\n\nReturns:True when touched, False otherwise.\n\nReturn type:bool\n\n\n\n"},
{"name": "time.struct_time", "args": ["(tm_year", "tm_mon", "tm_mday", "tm_hour", "tm_min", "tm_sec", "tm_wday", "tm_yday", "tm_isdst)"], "description": "Structure used to capture a date and time. Note that it takes a tuple!\n\n\nParameters:\ntm_year (int) \u2013 the year, 2017 for example\ntm_mon (int) \u2013 the month, range [1, 12]\ntm_mday (int) \u2013 the day of the month, range [1, 31]\ntm_hour (int) \u2013 the hour, range [0, 23]\ntm_min (int) \u2013 the minute, range [0, 59]\ntm_sec (int) \u2013 the second, range [0, 61]\ntm_wday (int) \u2013 the day of the week, range [0, 6], Monday is 0\ntm_yday (int) \u2013 the day of the year, range [1, 366], -1 indicates not known\ntm_isdst (int) \u2013 1 when in daylight savings, 0 when not, -1 if unknown."},
{"name": "storage.mount", "args": ["filesystem", "mount_path", "*", "readonly=False"], "description": "Mounts the given filesystem object at the given path.\nThis is the CircuitPython analog to the UNIX mount command.\n"},
{"name": "storage.umount", "args": ["mount"], "description": "Unmounts the given filesystem object or if mount is a path, then unmount\nthe filesystem mounted at that location.\nThis is the CircuitPython analog to the UNIX umount command.\n"},
{"name": "storage.remount", "args": ["mount_path", "readonly"], "description": "Remounts the given path with new parameters.\n"},
{"name": "storage.VfsFat", "args": ["block_device"], "description": "Create a new VfsFat filesystem around the given block device.\n\n\nParameters:block_device \u2013 Block device the the filesystem lives on"},
{"name": "pulseio.PWMOut", "args": ["pin", "*", "duty_cycle=0", "frequency=500", "variable_frequency=False"], "description": "Create a PWM object associated with the given pin. This allows you to\nwrite PWM signals out on the given pin. Frequency is fixed after init\nunless variable_frequency is True.\n\n\nParameters:\npin (Pin) \u2013 The pin to output to\nduty_cycle (int) \u2013 The fraction of each pulse which is high. 16-bit\nfrequency (int) \u2013 The target frequency in Hertz (32-bit)\nvariable_frequency (bool) \u2013 True if the frequency will change over time"},
{"name": "pulseio.PulseOut", "args": ["carrier"], "description": "Create a PulseOut object associated with the given PWM out experience.\n\n\nParameters:carrier (PWMOut) \u2013 PWMOut that is set to output on the desired pin."},
{"name": "pulseio.PWMOut.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PWMOut.duty_cycle", "args": null, "description": "16 bit value that dictates how much of one cycle is high (1) versus low\n(0). 0xffff will always be high, 0 will always be low and 0x7fff will\nbe half high and then half low.\n"},
{"name": "pulseio.PWMOut.frequency", "args": null, "description": "32 bit value that dictates the PWM frequency in Hertz (cycles per\nsecond). Only writeable when constructed with variable_frequency=True.\n"},
{"name": "random.seed", "args": ["seed"], "description": "Sets the starting seed of the random  number generation. Further calls to\nrandom will return deterministic results afterwards.\n"},
{"name": "random.getrandbits", "args": ["k"], "description": "Returns an integer with k random bits.\n"},
{"name": "random.randrange", "args": ["stop"], "description": "Returns a randomly selected integer from range(start, stop, step).\n"},
{"name": "random.randint", "args": ["a", "b"], "description": "Returns a randomly selected integer between a and b inclusive. Equivalent\nto randrange(a, b + 1, 1)\n"},
{"name": "random.choice", "args": ["seq"], "description": "Returns a randomly selected element from the given sequence. Raises\nIndexError when the sequence is empty.\n"},
{"name": "random.random", "args": [], "description": "Returns a random float between 0 and 1.0.\n"},
{"name": "pulseio.PulseOut.deinit", "args": [], "description": "Deinitialises the PulseOut and releases any hardware resources for reuse.\n"},
{"name": "random.uniform", "args": ["a", "b"], "description": "Returns a random float between a and b. It may or may not be inclusive\ndepending on float rounding.\n"},
{"name": "busio.UART", "args": ["tx", "rx", "*", "baudrate=9600", "bits=8", "parity=None", "stop=1", "timeout=1000", "receiver_buffer_size=64"], "description": "A common bidirectional serial protocol that uses an an agreed upon speed\nrather than a shared clock line.\n\n\nParameters:\ntx (Pin) \u2013 the pin to transmit with\nrx (Pin) \u2013 the pin to receive on\nbaudrate (int) \u2013 the transmit and receive speed"},
{"name": "busio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "busio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin connected to the OneWire bus"},
{"name": "busio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "busio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency in Hertz"},
{"name": "busio.UART.deinit", "args": [], "description": "Deinitialises the UART and releases any hardware resources for reuse.\n"},
{"name": "busio.UART.Parity", "args": [], "description": "Enum-like class to define the parity used to verify correct data transfer.\n\n"},
{"name": "busio.UART.Parity.ODD", "args": null, "description": "Total number of ones should be odd.\n"},
{"name": "busio.UART.Parity.EVEN", "args": null, "description": "Total number of ones should be even.\n"},
{"name": "busio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "busio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "bitbangio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin to read pulses from."},
{"name": "bitbangio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "bitbangio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "bitbangio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency of the bus"},
{"name": "bitbangio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "bitbangio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "audioio.AudioOut", "args": ["pin", "sample_source"], "description": "Create a AudioOut object associated with the given pin. This allows you to\nplay audio signals out on the given pin. Sample_source must be a bytes-like object.\n\nThe sample itself should consist of 16 bit samples and be mono.\nMicrocontrollers with a lower output resolution will use the highest order\nbits to output. For example, the SAMD21 has a 10 bit DAC that ignores the\nlowest 6 bits when playing 16 bit samples.\n\n\nParameters:\npin (Pin) \u2013 The pin to output to\nsample_source (bytes-like) \u2013 The source of the sample"},
{"name": "audioio.AudioOut.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "audioio.AudioOut.playing", "args": null, "description": "True when the audio sample is being output.\n"},
{"name": "audioio.AudioOut.frequency", "args": null, "description": "32 bit value that dictates how quickly samples are loaded into the DAC\nin Hertz (cycles per second). When the sample is looped, this can change\nthe pitch output without changing the underlying sample.\n"},
{"name": "audiobusio.PDMIn", "args": ["clock_pin", "data_pin", "*", "frequency=8000", "bit_depth=8", "mono=True", "oversample=64"], "description": "Create a PDMIn object associated with the given pins. This allows you to\nrecord audio signals from the given pins. Individual ports may put further\nrestrictions on the recording parameters.\n\n\nParameters:\nclock_pin (Pin) \u2013 The pin to output the clock to\ndata_pin (Pin) \u2013 The pin to read the data from\nfrequency (int) \u2013 Target frequency of the resulting samples. Check frequency for real value.\nbit_depth (int) \u2013 Final number of bits per sample. Must be divisible by 8\nmono (bool) \u2013 True when capturing a single channel of audio, captures two channels otherwise\noversample (int) \u2013 Number of single bit samples to decimate into a final sample. Must be divisible by 8"},
{"name": "audiobusio.PDMIn.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "audiobusio.PDMIn.frequency", "args": null, "description": "The actual frequency of the recording. This may not match the constructed\nfrequency due to internal clock limitations.\n"},
{"name": "analogio.AnalogOut", "args": ["pin"], "description": "Use the AnalogOut on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to output to"},
{"name": "analogio.AnalogOut.deinit", "args": [], "description": "Turn off the AnalogOut and release the pin for other use.\n"},
{"name": "analogio.AnalogOut.value", "args": null, "description": "The value on the analog pin.  The value must be between 0 and 65535\ninclusive (16-bit). Even if the underlying digital to analog converter\nis lower resolution, the input must be scaled to be 16-bit.\n\n\n\n\nReturns:the last value written\n\nReturn type:int\n\n\n\n"},
{"name": "analogio.AnalogIn", "args": ["pin"], "description": "Use the AnalogIn on the given pin. The reference voltage varies by\nplatform so use reference_voltage to read the configured setting.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "analogio.AnalogIn.deinit", "args": [], "description": "Turn off the AnalogIn and release the pin for other use.\n"},
{"name": "analogio.AnalogIn.value", "args": null, "description": "Read the value on the analog pin and return it.  The returned value\nwill be between 0 and 65535 inclusive (16-bit). Even if the underlying\nanalog to digital converter (ADC) is lower resolution, the result will\nbe scaled to be 16-bit.\n\n\n\n\nReturns:the data read\n\nReturn type:int\n\n\n\n"},
{"name": "analogio.AnalogIn.reference_voltage", "args": null, "description": "The maximum voltage measurable. Also known as the reference voltage.\n\n\n\n\nReturns:the reference voltage\n\nReturn type:float\n\n\n\n"},
{"name": "_stage.render", "args": ["x0", "y0", "x1", "y1", "layers", "buffer", "spi"], "description": "Render and send to the display a fragment of the screen.\n\n\n\n\nParameters:\nx0 (int) \u2013 Left edge of the fragment.\ny0 (int) \u2013 Top edge of the fragment.\nx1 (int) \u2013 Right edge of the fragment.\ny1 (int) \u2013 Bottom edge of the fragment.\nlayers (list) \u2013 A list of the Layer objects.\nbuffer (bytearray) \u2013 A buffer to use for rendering.\nspi (SPI) \u2013 The SPI bus to use.\n\n\n\n\n\nNote that this function only sends the raw pixel data. Setting up\nthe display for receiving it and handling the chip-select and\ndata-command pins has to be done outside of it.\nThere are also no sanity checks, outside of the basic overflow\nchecking. The caller is responsible for making the passed parameters\nvalid.\nThis function is intended for internal use in the stage library\nand all the necessary checks are performed there.\n"},
{"name": "digitalio.DriveMode", "args": [], "description": "Enum-like class to define the drive mode used when outputting\ndigital values.\n\n"},
{"name": "digitalio.DriveMode.PUSH_PULL", "args": null, "description": "Output both high and low digital values\n"},
{"name": "digitalio.DriveMode.OPEN_DRAIN", "args": null, "description": "Output low digital values but go into high z for digital high. This is\nuseful for i2c and other protocols that share a digital line.\n"},
{"name": "microcontroller.Processor", "args": [], "description": "You cannot create an instance of microcontroller.Processor.\nUse microcontroller.cpu to access the sole instance available.\n\n"},
{"name": "microcontroller.Processor.frequency", "args": null, "description": "The CPU operating frequency as an int, in Hertz. (read-only)\n"},
{"name": "microcontroller.Processor.temperature", "args": null, "description": "The on-chip temperature, in Celsius, as a float. (read-only)\nIs None if the temperature is not available.\n"},
{"name": "microcontroller.Processor.uid", "args": null, "description": "The unique id (aka serial number) of the chip as a bytearray. (read-only)\n"},
{"name": "digitalio.DigitalInOut.Direction", "args": [], "description": "Enum-like class to define which direction the digital values are\ngoing.\n\n"},
{"name": "digitalio.DigitalInOut.Direction.INPUT", "args": null, "description": "Read digital data in\n"},
{"name": "digitalio.DigitalInOut.Direction.OUTPUT", "args": null, "description": "Write digital data out\n"},
{"name": "gamepad.GamePad", "args": ["b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8"], "description": "Initializes button scanning routines.\n\nThe b1-b8 parameters are DigitalInOut objects, which\nimmediately get switched to input with a pull-up, and then scanned\nregularly for button presses. The order is the same as the order of\nbits returned by the get_pressed function. You can re-initialize\nit with different keys, then the new object will replace the previous\none.\n\nThe basic feature required here is the ability to poll the keys at\nregular intervals (so that de-bouncing is consistent) and fast enough\n(so that we don\u2019t miss short button presses) while at the same time\nletting the user code run normally, call blocking functions and wait\non delays.\n\nThey button presses are accumulated, until the get_pressed method\nis called, at which point the button state is cleared, and the new\nbutton presses start to be recorded.\n\n"},
{"name": "gamepad.GamePad.get_pressed", "args": [], "description": "Get the status of buttons pressed since the last call and clear it.\nReturns an 8-bit number, with bits that correspond to buttons,\nwhich have been pressed (or held down) since the last call to this\nfunction set to 1, and the remaining bits set to 0. Then it clears\nthe button state, so that new button presses (or buttons that are\nheld down) can be recorded for the next call.\n"},
{"name": "gamepad.GamePad.deinit", "args": [], "description": "Disable button scanning.\n"},
{"name": "math.acos", "args": ["x"], "description": "Return the inverse cosine of x.\n"},
{"name": "math.asin", "args": ["x"], "description": "Return the inverse sine of x.\n"},
{"name": "math.atan", "args": ["x"], "description": "Return the inverse tangent of x.\n"},
{"name": "math.atan2", "args": ["y", "x"], "description": "Return the principal value of the inverse tangent of y/x.\n"},
{"name": "microcontroller.Pin", "args": [], "description": "Identifies an IO pin on the microcontroller. They are fixed by the\nhardware so they cannot be constructed on demand. Instead, use\nboard or microcontroller.pin to reference the desired pin.\n\n"},
{"name": "math.ceil", "args": ["x"], "description": "Return an integer, being x rounded towards positive infinity.\n"},
{"name": "math.copysign", "args": ["x", "y"], "description": "Return x with the sign of y.\n"},
{"name": "math.cos", "args": ["x"], "description": "Return the cosine of x.\n"},
{"name": "math.degrees", "args": ["x"], "description": "Return radians x converted to degrees.\n"},
{"name": "math.exp", "args": ["x"], "description": "Return the exponential of x.\n"},
{"name": "math.fabs", "args": ["x"], "description": "Return the absolute value of x.\n"},
{"name": "math.floor", "args": ["x"], "description": "Return an integer, being x rounded towards negative infinity.\n"},
{"name": "math.fmod", "args": ["x", "y"], "description": "Return the remainder of x/y.\n"},
{"name": "math.frexp", "args": ["x"], "description": "Decomposes a floating-point number into its mantissa and exponent.\nThe returned value is the tuple (m, e) such that x == m * 2**e\nexactly.  If x == 0 then the function returns (0.0, 0), otherwise\nthe relation 0.5 <= abs(m) < 1 holds.\n"},
{"name": "math.isfinite", "args": ["x"], "description": "Return True if x is finite.\n"},
{"name": "math.isinf", "args": ["x"], "description": "Return True if x is infinite.\n"},
{"name": "math.isnan", "args": ["x"], "description": "Return True if x is not-a-number\n"},
{"name": "math.ldexp", "args": ["x", "exp"], "description": "Return x * (2**exp).\n"},
{"name": "digitalio.Pull", "args": [], "description": "Enum-like class to define the pull value, if any, used while reading\ndigital values in.\n\n"},
{"name": "digitalio.Pull.UP", "args": null, "description": "When the input line isn\u2019t being driven the pull up can pull the state\nof the line high so it reads as true.\n"},
{"name": "digitalio.Pull.DOWN", "args": null, "description": "When the input line isn\u2019t being driven the pull down can pull the\nstate of the line low so it reads as false.\n"},
{"name": "digitalio.DigitalInOut", "args": ["pin"], "description": "Create a new DigitalInOut object associated with the pin. Defaults to input\nwith no pull. Use switch_to_input() and\nswitch_to_output() to change the direction.\n\n\nParameters:pin (Pin) \u2013 The pin to control"},
{"name": "math.modf", "args": ["x"], "description": "Return a tuple of two floats, being the fractional and integral parts of\nx.  Both return values have the same sign as x.\n"},
{"name": "math.pow", "args": ["x", "y"], "description": "Returns x to the power of y.\n"},
{"name": "math.radians", "args": ["x"], "description": "Return degrees x converted to radians.\n"},
{"name": "math.sin", "args": ["x"], "description": "Return the sine of x.\n"},
{"name": "math.sqrt", "args": ["x"], "description": "Returns the square root of x.\n"},
{"name": "math.tan", "args": ["x"], "description": "Return the tangent of x.\n"},
{"name": "math.trunc", "args": ["x"], "description": "Return an integer, being x rounded towards 0.\n"},
{"name": "digitalio.DigitalInOut.deinit", "args": [], "description": "Turn off the DigitalInOut and release the pin for other use.\n"},
{"name": "digitalio.DigitalInOut.direction", "args": null, "description": "The direction of the pin.\nSetting this will use the defaults from the corresponding\nswitch_to_input() or switch_to_output() method. If\nyou want to set pull, value or drive mode prior to switching, then use\nthose methods instead.\n"},
{"name": "digitalio.DigitalInOut.value", "args": null, "description": "The digital logic level of the pin.\n"},
{"name": "digitalio.DigitalInOut.drive_mode", "args": null, "description": "The pin drive mode. One of:\n\ndigitalio.DriveMode.PUSH_PULL\ndigitalio.DriveMode.OPEN_DRAIN\n\n"},
{"name": "digitalio.DigitalInOut.pull", "args": null, "description": "The pin pull direction. One of:\n\ndigitalio.Pull.UP\ndigitalio.Pull.DOWN\nNone\n\n\n\n\n\nRaises:AttributeError \u2013 if direction is OUTPUT.\n\n\n\n"},
{"name": "busio.UART", "args": ["tx", "rx", "*", "baudrate=9600", "bits=8", "parity=None", "stop=1", "timeout=1000", "receiver_buffer_size=64"], "description": "A common bidirectional serial protocol that uses an an agreed upon speed\nrather than a shared clock line.\n\n\nParameters:\ntx (Pin) \u2013 the pin to transmit with, or None if this UART is receive-only.\nrx (Pin) \u2013 the pin to receive on, or None if this UART is transmit-only.\nbaudrate (int) \u2013 the transmit and receive speed."},
{"name": "busio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "busio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin connected to the OneWire bus"},
{"name": "busio.UART.deinit", "args": [], "description": "Deinitialises the UART and releases any hardware resources for reuse.\n"},
{"name": "busio.UART.baudrate", "args": null, "description": "The current baudrate.\n"},
{"name": "busio.UART.Parity", "args": [], "description": "Enum-like class to define the parity used to verify correct data transfer.\n\n"},
{"name": "busio.UART.Parity.ODD", "args": null, "description": "Total number of ones should be odd.\n"},
{"name": "busio.UART.Parity.EVEN", "args": null, "description": "Total number of ones should be even.\n"},
{"name": "busio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "busio.SPI.frequency", "args": null, "description": "The actual SPI bus frequency. This may not match the frequency requested\ndue to internal limitations.\n"},
{"name": "busio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "busio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency in Hertz\ntimeout (int) \u2013 The maximum clock stretching timeut - only for bitbang"},
{"name": "usb_hid.Device", "args": [], "description": "Not currently dynamically supported.\n\n"},
{"name": "usb_hid.Device.send_report", "args": ["buf"], "description": "Send a HID report.\n"},
{"name": "usb_hid.Device.usage_page", "args": null, "description": "The usage page of the device as an int. Can be thought of a category. (read-only)\n"},
{"name": "usb_hid.Device.usage", "args": null, "description": "The functionality of the device as an int. (read-only)\nFor example, Keyboard is 0x06 within the generic desktop usage page 0x01.\nMouse is 0x02 within the same usage page.\n"},
{"name": "busio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "touchio.TouchIn", "args": ["pin"], "description": "Use the TouchIn on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "touchio.TouchIn.deinit", "args": [], "description": "Deinitialises the TouchIn and releases any hardware resources for reuse.\n"},
{"name": "touchio.TouchIn.value", "args": null, "description": "Whether the touch pad is being touched or not. (read-only)\nTrue when raw_value > threshold.\n"},
{"name": "touchio.TouchIn.raw_value", "args": null, "description": "The raw touch measurement as an int. (read-only)\n"},
{"name": "touchio.TouchIn.threshold", "args": null, "description": "Minimum raw_value needed to detect a touch (and for value to be True).\nWhen the TouchIn object is created, an initial raw_value is read from the pin,\nand then threshold is set to be 100 + that value.\nYou can adjust threshold to make the pin more or less sensitive.\n"},
{"name": "supervisor.Runtime", "args": [], "description": "You cannot create an instance of supervisor.Runtime.\nUse supervisor.runtime to access the sole instance available.\n\n"},
{"name": "supervisor.Runtime.serial_connected", "args": null, "description": "Returns the USB serial communication status (read-only).\n"},
{"name": "struct.calcsize", "args": ["fmt"], "description": "Return the number of bytes needed to store the given fmt.\n"},
{"name": "struct.pack", "args": ["fmt", "v1", "v2", "..."], "description": "Pack the values v1, v2, \u2026 according to the format string fmt.\nThe return value is a bytes object encoding the values.\n"},
{"name": "struct.pack_into", "args": ["fmt", "buffer", "offset", "v1", "v2", "..."], "description": "Pack the values v1, v2, \u2026 according to the format string fmt into a buffer\nstarting at offset. offset may be negative to count from the end of buffer.\n"},
{"name": "struct.unpack", "args": ["fmt", "data"], "description": "Unpack from the data according to the format string fmt. The return value\nis a tuple of the unpacked values.\n"},
{"name": "struct.unpack_from", "args": ["fmt", "data", "offset"], "description": "Unpack from the data starting at offset according to the format string fmt.\noffset may be negative to count from the end of buffer. The return value is\na tuple of the unpacked values.\n"},
{"name": "time.struct_time", "args": ["(tm_year", "tm_mon", "tm_mday", "tm_hour", "tm_min", "tm_sec", "tm_wday", "tm_yday", "tm_isdst)"], "description": "Structure used to capture a date and time. Note that it takes a tuple!\n\n\nParameters:\ntm_year (int) \u2013 the year, 2017 for example\ntm_mon (int) \u2013 the month, range [1, 12]\ntm_mday (int) \u2013 the day of the month, range [1, 31]\ntm_hour (int) \u2013 the hour, range [0, 23]\ntm_min (int) \u2013 the minute, range [0, 59]\ntm_sec (int) \u2013 the second, range [0, 61]\ntm_wday (int) \u2013 the day of the week, range [0, 6], Monday is 0\ntm_yday (int) \u2013 the day of the year, range [1, 366], -1 indicates not known\ntm_isdst (int) \u2013 1 when in daylight savings, 0 when not, -1 if unknown."},
{"name": "rtc.set_time_source", "args": ["rtc"], "description": "Sets the rtc time source used by time.localtime().\nThe default is rtc.RTC().\nExample usage:\nimport rtc\nimport time\n\nclass RTC(object):\n    @property\n    def datetime(self):\n        return time.struct_time((2018, 3, 17, 21, 1, 47, 0, 0, 0))\n\nr = RTC()\nrtc.set_time_source(r)\n\n\n"},
{"name": "rtc.RTC", "args": [], "description": "This class represents the onboard Real Time Clock. It is a singleton and will always return the same instance.\n\n"},
{"name": "rtc.RTC.datetime", "args": null, "description": "The date and time of the RTC.\n"},
{"name": "rtc.RTC.calibration", "args": null, "description": "The RTC calibration value.\nA positive value speeds up the clock and a negative value slows it down.\nRange and value is hardware specific, but one step is often approx. 1 ppm.\n"},
{"name": "storage.mount", "args": ["filesystem", "mount_path", "*", "readonly=False"], "description": "Mounts the given filesystem object at the given path.\nThis is the CircuitPython analog to the UNIX mount command.\n"},
{"name": "storage.umount", "args": ["mount"], "description": "Unmounts the given filesystem object or if mount is a path, then unmount\nthe filesystem mounted at that location.\nThis is the CircuitPython analog to the UNIX umount command.\n"},
{"name": "storage.remount", "args": ["mount_path", "readonly=False"], "description": "Remounts the given path with new parameters.\n"},
{"name": "storage.getmount", "args": ["mount_path"], "description": "Retrieves the mount object associated with the mount path\n"},
{"name": "storage.erase_filesystem", "args": [], "description": "Erase and re-create the CIRCUITPY filesystem.\nOn boards that present USB-visible CIRCUITPY drive (e.g., SAMD21 and SAMD51),\nthen call microcontroller.reset() to restart CircuitPython and have the\nhost computer remount CIRCUITPY.\nThis function can be called from the REPL when CIRCUITPY\nhas become corrupted.\n\nWarning\nAll the data on CIRCUITPY will be lost, and\nCircuitPython will restart on certain boards.\n\n"},
{"name": "storage.VfsFat", "args": ["block_device"], "description": "Create a new VfsFat filesystem around the given block device.\n\n\nParameters:block_device \u2013 Block device the the filesystem lives on"},
{"name": "storage.VfsFat.mkfs", "args": [], "description": "Format the block device, deleting any data that may have been there\n"},
{"name": "storage.VfsFat.open", "args": ["path", "mode"], "description": "Like builtin open()\n"},
{"name": "storage.VfsFat.ilistdir", "args": ["path"], "description": "Return an iterator whose values describe files and folders within\npath\n"},
{"name": "storage.VfsFat.mkdir", "args": ["path"], "description": "Like os.mkdir\n"},
{"name": "storage.VfsFat.rmdir", "args": ["path"], "description": "Like os.rmdir\n"},
{"name": "storage.VfsFat.stat", "args": ["path"], "description": "Like os.stat\n"},
{"name": "storage.VfsFat.statvfs", "args": ["path"], "description": "Like os.statvfs\n"},
{"name": "storage.VfsFat.mount", "args": ["readonly", "mkfs"], "description": "Don\u2019t call this directly, call storage.mount.\n"},
{"name": "storage.VfsFat.umount", "args": [], "description": "Don\u2019t call this directly, call storage.umount.\n"},
{"name": "storage.VfsFat.label", "args": null, "description": "The filesystem label, up to 11 case-insensitive bytes.  Note that\nthis property can only be set when the device is writable by the\nmicrocontroller.\n"},
{"name": "random.seed", "args": ["seed"], "description": "Sets the starting seed of the random  number generation. Further calls to\nrandom will return deterministic results afterwards.\n"},
{"name": "random.getrandbits", "args": ["k"], "description": "Returns an integer with k random bits.\n"},
{"name": "random.randrange", "args": ["stop"], "description": "Returns a randomly selected integer from range(start, stop, step).\n"},
{"name": "random.randint", "args": ["a", "b"], "description": "Returns a randomly selected integer between a and b inclusive. Equivalent\nto randrange(a, b + 1, 1)\n"},
{"name": "random.choice", "args": ["seq"], "description": "Returns a randomly selected element from the given sequence. Raises\nIndexError when the sequence is empty.\n"},
{"name": "random.random", "args": [], "description": "Returns a random float between 0 and 1.0.\n"},
{"name": "rotaryio.IncrementalEncoder", "args": ["pin_a", "pin_b"], "description": "Create an IncrementalEncoder object associated with the given pins. It tracks the positional\nstate of an incremental rotary encoder (also known as a quadrature encoder.) Position is\nrelative to the position when the object is contructed.\n\n\nParameters:\npin_a (Pin) \u2013 First pin to read pulses from.\npin_b (Pin) \u2013 Second pin to read pulses from."},
{"name": "rotaryio.IncrementalEncoder.deinit", "args": [], "description": "Deinitializes the IncrementalEncoder and releases any hardware resources for reuse.\n"},
{"name": "rotaryio.IncrementalEncoder.position", "args": null, "description": "The current position in terms of pulses. The number of pulses per rotation is defined by the\nspecific hardware.\n"},
{"name": "random.uniform", "args": ["a", "b"], "description": "Returns a random float between a and b. It may or may not be inclusive\ndepending on float rounding.\n"},
{"name": "pulseio.PWMOut", "args": ["pin", "*", "duty_cycle=0", "frequency=500", "variable_frequency=False"], "description": "Create a PWM object associated with the given pin. This allows you to\nwrite PWM signals out on the given pin. Frequency is fixed after init\nunless variable_frequency is True.\n\n\nParameters:\npin (Pin) \u2013 The pin to output to\nduty_cycle (int) \u2013 The fraction of each pulse which is high. 16-bit\nfrequency (int) \u2013 The target frequency in Hertz (32-bit)\nvariable_frequency (bool) \u2013 True if the frequency will change over time"},
{"name": "pulseio.PulseOut", "args": ["carrier"], "description": "Create a PulseOut object associated with the given PWM out experience.\n\n\nParameters:carrier (PWMOut) \u2013 PWMOut that is set to output on the desired pin."},
{"name": "pulseio.PulseOut.deinit", "args": [], "description": "Deinitialises the PulseOut and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PulseIn", "args": ["pin", "maxlen=2", "*", "idle_state=False"], "description": "Create a PulseIn object associated with the given pin. The object acts as\na read-only sequence of pulse lengths with a given max length. When it is\nactive, new pulse lengths are added to the end of the list. When there is\nno more room (len() == maxlen) the oldest pulse length is removed to\nmake room.\n\n\nParameters:\npin (Pin) \u2013 Pin to read pulses from.\nmaxlen (int) \u2013 Maximum number of pulse durations to store at once\nidle_state (bool) \u2013 Idle state of the pin. At start and after resume\nthe first recorded pulse will the opposite state from idle."},
{"name": "pulseio.PWMOut.deinit", "args": [], "description": "Deinitialises the PWMOut and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PWMOut.duty_cycle", "args": null, "description": "16 bit value that dictates how much of one cycle is high (1) versus low\n(0). 0xffff will always be high, 0 will always be low and 0x7fff will\nbe half high and then half low.\n"},
{"name": "pulseio.PWMOut.frequency", "args": null, "description": "32 bit value that dictates the PWM frequency in Hertz (cycles per\nsecond). Only writeable when constructed with variable_frequency=True.\n"},
{"name": "pulseio.PulseIn.deinit", "args": [], "description": "Deinitialises the PulseIn and releases any hardware resources for reuse.\n"},
{"name": "pulseio.PulseIn.maxlen", "args": null, "description": "The maximum length of the PulseIn. When len() is equal to maxlen,\nit is unclear which pulses are active and which are idle.\n"},
{"name": "pulseio.PulseIn.paused", "args": null, "description": "True when pulse capture is paused as a result of pause() or an error during capture\nsuch as a signal that is too fast.\n"},
{"name": "os.uname", "args": [], "description": "Returns a named tuple of operating specific and CircuitPython port\nspecific information.\n"},
{"name": "os.chdir", "args": ["path"], "description": "Change current directory.\n"},
{"name": "os.getcwd", "args": [], "description": "Get the current directory.\n"},
{"name": "os.listdir", "args": ["dir"], "description": "With no argument, list the current directory.  Otherwise list the given directory.\n"},
{"name": "os.mkdir", "args": ["path"], "description": "Create a new directory.\n"},
{"name": "os.remove", "args": ["path"], "description": "Remove a file.\n"},
{"name": "nvm.ByteArray", "args": [], "description": "Not currently dynamically supported. Access the sole instance through microcontroller.nvm.\n\n"},
{"name": "os.rmdir", "args": ["path"], "description": "Remove a directory.\n"},
{"name": "os.rename", "args": ["old_path", "new_path"], "description": "Rename a file.\n"},
{"name": "os.stat", "args": ["path"], "description": "Get the status of a file or directory.\n"},
{"name": "os.statvfs", "args": ["path"], "description": "Get the status of a fileystem.\nReturns a tuple with the filesystem information in the following order:\n\n\nf_bsize \u2013 file system block size\nf_frsize \u2013 fragment size\nf_blocks \u2013 size of fs in f_frsize units\nf_bfree \u2013 number of free blocks\nf_bavail \u2013 number of free blocks for unpriviliged users\nf_files \u2013 number of inodes\nf_ffree \u2013 number of free inodes\nf_favail \u2013 number of free inodes for unpriviliged users\nf_flag \u2013 mount flags\nf_namemax \u2013 maximum filename length\n\n\nParameters related to inodes: f_files, f_ffree, f_avail\nand the f_flags parameter may return 0 as they can be unavailable\nin a port-specific implementation.\n"},
{"name": "os.sync", "args": [], "description": "Sync all filesystems.\n"},
{"name": "os.urandom", "args": ["size"], "description": "Returns a string of size random bytes based on a hardware True Random\nNumber Generator. When not available, it will raise a NotImplementedError.\n"},
{"name": "microcontroller.RunMode", "args": [], "description": "Enum-like class to define the run mode of the microcontroller and\nCircuitPython.\n\n"},
{"name": "microcontroller.RunMode.NORMAL", "args": null, "description": "Run CircuitPython as normal.\n"},
{"name": "microcontroller.RunMode.SAFE_MODE", "args": null, "description": "Run CircuitPython in safe mode. User code will not be run and the\nfile system will be writeable over USB.\n"},
{"name": "microcontroller.RunMode.BOOTLOADER", "args": null, "description": "Run the bootloader.\n"},
{"name": "multiterminal.get_secondary_terminal", "args": [], "description": "Returns the current secondary terminal.\n"},
{"name": "multiterminal.set_secondary_terminal", "args": ["stream"], "description": "Read additional input from the given stream and write out back to it.\nThis doesn\u2019t replace the core stream (usually UART or native USB) but is\nmixed in instead.\n\n\n\n\nParameters:stream (stream) \u2013 secondary stream\n\n\n\n"},
{"name": "multiterminal.clear_secondary_terminal", "args": [], "description": "Clears the secondary terminal.\n"},
{"name": "multiterminal.schedule_secondary_terminal_read", "args": ["socket"], "description": "In cases where the underlying OS is doing task scheduling, this notifies\nthe OS when more data is available on the socket to read. This is useful\nas a callback for lwip sockets.\n"},
{"name": "bitbangio.OneWire", "args": ["pin"], "description": "Create a OneWire object associated with the given pin. The object\nimplements the lowest level timing-sensitive bits of the protocol.\n\n\nParameters:pin (Pin) \u2013 Pin to read pulses from."},
{"name": "bitbangio.OneWire.deinit", "args": [], "description": "Deinitialize the OneWire bus and release any hardware resources for reuse.\n"},
{"name": "bitbangio.SPI", "args": ["clock", "MOSI=None", "MISO=None"], "description": "\nParameters:\nclock (Pin) \u2013 the pin to use for the clock.\nMOSI (Pin) \u2013 the Master Out Slave In pin.\nMISO (Pin) \u2013 the Master In Slave Out pin."},
{"name": "bitbangio.SPI.deinit", "args": [], "description": "Turn off the SPI bus.\n"},
{"name": "bitbangio.I2C", "args": ["scl", "sda", "*", "frequency=400000"], "description": "I2C is a two-wire protocol for communicating between devices.  At the\nphysical level it consists of 2 wires: SCL and SDA, the clock and data\nlines respectively.\n\n\nParameters:\nscl (Pin) \u2013 The clock pin\nsda (Pin) \u2013 The data pin\nfrequency (int) \u2013 The clock frequency of the bus\ntimeout (int) \u2013 The maximum clock stretching timeout in microseconds"},
{"name": "bitbangio.I2C.deinit", "args": [], "description": "Releases control of the underlying hardware so other classes can use it.\n"},
{"name": "audioio.RawSample", "args": ["buffer", "*", "channel_count=1", "sample_rate=8000"], "description": "Create a RawSample based on the given buffer of signed values. If channel_count is more than\n1 then each channel\u2019s samples should alternate. In other words, for a two channel buffer, the\nfirst sample will be for channel 1, the second sample will be for channel two, the third for\nchannel 1 and so on.\n\n\nParameters:\nbuffer (array) \u2013 An array.array with samples\nchannel_count (int) \u2013 The number of channels in the buffer\nsample_rate (int) \u2013 The desired playback sample rate"},
{"name": "audioio.RawSample.deinit", "args": [], "description": "Deinitialises the AudioOut and releases any hardware resources for reuse.\n"},
{"name": "audioio.RawSample.sample_rate", "args": null, "description": "32 bit value that dictates how quickly samples are played in Hertz (cycles per second).\nWhen the sample is looped, this can change the pitch output without changing the underlying\nsample. This will not change the sample rate of any active playback. Call play again to\nchange it.\n"},
{"name": "audioio.WaveFile", "args": ["filename"], "description": "Load a .wav file for playback with audioio.AudioOut or audiobusio.I2SOut.\n\n\nParameters:file (bytes-like) \u2013 Already opened wave file"},
{"name": "audioio.WaveFile.deinit", "args": [], "description": "Deinitialises the WaveFile and releases all memory resources for reuse.\n"},
{"name": "audioio.WaveFile.sample_rate", "args": null, "description": "32 bit value that dictates how quickly samples are loaded into the DAC\nin Hertz (cycles per second). When the sample is looped, this can change\nthe pitch output without changing the underlying sample.\n"},
{"name": "audiobusio.I2SOut", "args": ["bit_clock", "word_select", "data", "*", "left_justified"], "description": "Create a I2SOut object associated with the given pins.\n\n\nParameters:\nbit_clock (Pin) \u2013 The bit clock (or serial clock) pin\nword_select (Pin) \u2013 The word select (or left/right clock) pin\ndata (Pin) \u2013 The data pin\nleft_justified (bool) \u2013 True when data bits are aligned with the word select clock. False\nwhen they are shifted by one to match classic I2S protocol."},
{"name": "audiobusio.PDMIn", "args": ["clock_pin", "data_pin", "*", "sample_rate=16000", "bit_depth=8", "mono=True", "oversample=64", "startup_delay=0.11"], "description": "Create a PDMIn object associated with the given pins. This allows you to\nrecord audio signals from the given pins. Individual ports may put further\nrestrictions on the recording parameters. The overall sample rate is\ndetermined by sample_rate x oversample, and the total must be 1MHz or\nhigher, so sample_rate must be a minimum of 16000.\n\n\nParameters:\nclock_pin (Pin) \u2013 The pin to output the clock to\ndata_pin (Pin) \u2013 The pin to read the data from\nsample_rate (int) \u2013 Target sample_rate of the resulting samples. Check sample_rate for actual value.\nMinimum sample_rate is about 16000 Hz.\nbit_depth (int) \u2013 Final number of bits per sample. Must be divisible by 8\nmono (bool) \u2013 True when capturing a single channel of audio, captures two channels otherwise\noversample (int) \u2013 Number of single bit samples to decimate into a final sample. Must be divisible by 8\nstartup_delay (float) \u2013 seconds to wait after starting microphone clock\nto allow microphone to turn on. Most require only 0.01s; some require 0.1s. Longer is safer.\nMust be in range 0.0-1.0 seconds."},
{"name": "audiobusio.I2SOut.deinit", "args": [], "description": "Deinitialises the I2SOut and releases any hardware resources for reuse.\n"},
{"name": "audiobusio.I2SOut.playing", "args": null, "description": "True when the audio sample is being output. (read-only)\n"},
{"name": "audiobusio.I2SOut.paused", "args": null, "description": "True when playback is paused. (read-only)\n"},
{"name": "audiobusio.PDMIn.deinit", "args": [], "description": "Deinitialises the PDMIn and releases any hardware resources for reuse.\n"},
{"name": "audiobusio.PDMIn.sample_rate", "args": null, "description": "The actual sample_rate of the recording. This may not match the constructed\nsample rate due to internal clock limitations.\n"},
{"name": "analogio.AnalogOut", "args": ["pin"], "description": "Use the AnalogOut on the given pin.\n\n\nParameters:pin (Pin) \u2013 the pin to output to"},
{"name": "analogio.AnalogOut.deinit", "args": [], "description": "Turn off the AnalogOut and release the pin for other use.\n"},
{"name": "analogio.AnalogOut.value", "args": null, "description": "The value on the analog pin between 0 and 65535 inclusive (16-bit). (write-only)\nEven if the underlying digital to analog converter (DAC) is lower\nresolution, the value is 16-bit.\n"},
{"name": "_stage.Layer", "args": ["width", "height", "graphic", "palette", "grid"], "description": "Keep internal information about a layer of graphics (either a\nGrid or a Sprite) in a format suitable for fast rendering\nwith the render() function.\n\n\nParameters:\nwidth (int) \u2013 The width of the grid in tiles, or 1 for sprites.\nheight (int) \u2013 The height of the grid in tiles, or 1 for sprites.\ngraphic (bytearray) \u2013 The graphic data of the tiles.\npalette (bytearray) \u2013 The color palette to be used.\ngrid (bytearray) \u2013 The contents of the grid map."},
{"name": "_stage.Layer.move", "args": ["x", "y"], "description": ""},
{"name": "_stage.Layer.frame", "args": ["frame", "rotation"], "description": ""},
{"name": "_stage.Text", "args": ["width", "height", "font", "palette", "chars"], "description": "Keep internal information about a text of text\nin a format suitable for fast rendering\nwith the render() function.\n\n\nParameters:\nwidth (int) \u2013 The width of the grid in tiles, or 1 for sprites.\nheight (int) \u2013 The height of the grid in tiles, or 1 for sprites.\nfont (bytearray) \u2013 The font data of the characters.\npalette (bytearray) \u2013 The color palette to be used.\nchars (bytearray) \u2013 The contents of the character grid."},
{"name": "_stage.Text.move", "args": ["x", "y"], "description": ""},
{"name": "audioio.AudioOut", "args": ["left_channel", "right_channel=None"], "description": "Create a AudioOut object associated with the given pin(s). This allows you to\nplay audio signals out on the given pin(s).\n\n\nParameters:\nleft_channel (Pin) \u2013 The pin to output the left channel to\nright_channel (Pin) \u2013 The pin to output the right channel to"},
{"name": "audioio.AudioOut.deinit", "args": [], "description": "Deinitialises the AudioOut and releases any hardware resources for reuse.\n"},
{"name": "audioio.AudioOut.playing", "args": null, "description": "True when an audio sample is being output even if paused. (read-only)\n"},
{"name": "audioio.AudioOut.paused", "args": null, "description": "True when playback is paused. (read-only)\n"},
{"name": "analogio.AnalogIn", "args": ["pin"], "description": "Use the AnalogIn on the given pin. The reference voltage varies by\nplatform so use reference_voltage to read the configured setting.\n\n\nParameters:pin (Pin) \u2013 the pin to read from"},
{"name": "analogio.AnalogIn.deinit", "args": [], "description": "Turn off the AnalogIn and release the pin for other use.\n"},
{"name": "analogio.AnalogIn.value", "args": null, "description": "The value on the analog pin between 0 and 65535 inclusive (16-bit). (read-only)\nEven if the underlying analog to digital converter (ADC) is lower\nresolution, the value is 16-bit.\n"},
{"name": "analogio.AnalogIn.reference_voltage", "args": null, "description": "The maximum voltage measurable (also known as the reference voltage) as a\nfloat in Volts.\n"}
]
